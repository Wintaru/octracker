<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@500;700&display=swap" rel="stylesheet" />
  <title>OC South - Pots FATE Tracker</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { background: #0f0f1a; }
    body {
      min-height: 100vh;
      background: linear-gradient(135deg, #0f0f1a, #1a1a2e, #16213e);
      background-attachment: fixed;
      color: #e8e4dc;
      font-family: 'Segoe UI', system-ui, sans-serif;
      padding: 24px;
    }
    #root { max-width: 520px; margin: 0 auto; }
    @media (max-width: 480px) {
      body { padding: 12px; }
    }
    button { touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
  <script type="text/babel">
    const { useState, useEffect, useCallback } = React;

    // FATE n spawns at time 5 + 30*n; even n = North, odd n = South
    const FATE_START = 5;
    const FATE_INTERVAL = 30;
    function fateTime(n) { return FATE_START + FATE_INTERVAL * n; }
    function fateLoc(n) { return n % 2 === 0 ? "North" : "South"; }
    const TOLERANCE = 5;
    const SHARE_EPOCH = 1735689600000; // Jan 1 2025 UTC
    const WORD_CYCLE = 16384; // ~11.4 day cycle for modular time encoding
    const WORDS = [
      "flame","frost","stone","wind","thunder","water","shadow","light","ember","blaze","gale","quake","tide","spark","void","bloom",
      "dawn","dusk","moon","solar","lunar","astral","umbral","star","nova","comet","eclipse","zenith","corona","aurora","cosmos","nebula",
      "iron","gold","silver","bronze","cobalt","steel","brass","copper","ruby","pearl","opal","onyx","jade","amber","topaz","garnet",
      "ridge","vale","mesa","cliff","gorge","knoll","peak","dune","marsh","grove","glade","oasis","delta","basin","bluff","crest",
      "oak","pine","cedar","maple","willow","ivy","fern","moss","lotus","lily","rose","thorn","laurel","palm","reed","sage",
      "hawk","wolf","crane","raven","eagle","falcon","wren","orca","viper","moth","drake","wyrm","tiger","fox","stag","lark",
      "shard","crystal","prism","rune","glyph","sigil","seal","orb","helm","blade","lance","shield","crown","ring","staff","tome",
      "aether","arcane","oracle","knight","warden","herald","cipher","echo","myth","fable","rift","nexus","aegis","pyre","hymn","creed",
      "mist","rain","snow","haze","storm","breeze","sleet","cloud","dust","smoke","ash","dew","gust","drift","flurry","squall",
      "tower","spire","gate","arch","vault","forge","haven","keep","cairn","altar","shrine","bridge","harbor","beacon","fort","well",
      "river","shore","pond","brook","spring","falls","bay","trail","path","hollow","cavern","grotto","ravine","fjord","shoal","inlet",
      "azure","crimson","ivory","scarlet","violet","coral","obsidian","verdant","pale","bright","deep","wild","silent","ancient","swift","bold",
      "grace","honor","valor","fury","pride","hope","fate","glory","peace","wrath","quest","oath","vigil","trial","bond","spirit",
      "kindle","whisper","wander","soar","surge","shatter","mend","cleave","weave","summon","invoke","banish","temper","quench","ignite","meld",
      "north","south","east","west","above","below","inner","outer","first","last","high","low","near","far","true","free",
      "serpent","phoenix","griffin","chimera","sphinx","hydra","titan","golem","djinn","sprite","nymph","sylph","angel","demon","giant","shade"
    ];

    // Packs 4 values into 32 bits, encoded as 4 words (8 bits each)
    // t: 14 bits (minutes since epoch mod 16384, ~11 day cycle)
    // i: 8 bits (instance time in minutes, 0-255)
    // o: 8 bits (offset: round(offset*4)+128, Â±32 min at 0.25 precision)
    // u: 2 bits (uncertainty level)
    function encodeShareState(startRealTime, startInstanceTime, offset, uncertainty) {
      const t = Math.floor((startRealTime - SHARE_EPOCH) / 60000) & 0x3FFF;
      const i = Math.min(255, Math.max(0, Math.round(startInstanceTime)));
      const o = Math.min(255, Math.max(0, Math.round(offset * 4) + 128));
      const u = uncertainty >= 5 ? 0 : uncertainty >= 3 ? 3 : uncertainty >= 1 ? 1 : 2;
      const v = (t << 18) | (i << 10) | (o << 2) | u;
      return [WORDS[(v >>> 24) & 0xFF], WORDS[(v >>> 16) & 0xFF], WORDS[(v >>> 8) & 0xFF], WORDS[v & 0xFF]].join("-");
    }

    function decodeShareState(code) {
      if (!code) return null;
      // Legacy 9-char base36 format
      if (code.length === 9 && !code.includes("-")) {
        const t = parseInt(code.slice(0, 4), 36);
        const i = parseInt(code.slice(4, 6), 36);
        const o = parseInt(code.slice(6, 8), 36);
        const u = parseInt(code.slice(8, 9), 36);
        if ([t, i, o, u].some(isNaN)) return null;
        return { startRealTime: t * 60000 + SHARE_EPOCH, startInstanceTime: i, offset: (o - 300) / 10, uncertainty: u === 0 ? 5 : u === 3 ? 3 : u === 1 ? 1 : 0.5 };
      }
      // Word-based format
      const parts = code.split("-");
      if (parts.length !== 4) return null;
      const idx = parts.map(w => WORDS.indexOf(w.toLowerCase()));
      if (idx.some(j => j === -1)) return null;
      const v = (idx[0] << 24) | (idx[1] << 16) | (idx[2] << 8) | idx[3];
      const tMod = (v >>> 18) & 0x3FFF;
      const i = (v >>> 10) & 0xFF;
      const oEnc = (v >>> 2) & 0xFF;
      const u = v & 0x3;
      const nowMins = Math.floor((Date.now() - SHARE_EPOCH) / 60000);
      const diff = ((nowMins - tMod) % WORD_CYCLE + WORD_CYCLE) % WORD_CYCLE;
      const t = nowMins - diff;
      return { startRealTime: t * 60000 + SHARE_EPOCH, startInstanceTime: i, offset: (oEnc - 128) / 4, uncertainty: u === 0 ? 5 : u === 3 ? 3 : u === 1 ? 1 : 0.5 };
    }

    function fmtShort(mins) {
      if (mins < 0) return "\u2014";
      const m = Math.floor(mins);
      const s = Math.round((mins - m) * 60);
      return `${m}:${s.toString().padStart(2, "0")}`;
    }

    function fmtTime(mins) {
      const d = new Date(Date.now() + mins * 60000);
      return d.toLocaleTimeString([], { hour: "numeric", minute: "2-digit" });
    }

    function FateTracker() {
      const [playerMin, setPlayerMin] = useState("");
      const [joinCode, setJoinCode] = useState("");
      const [offset, setOffset] = useState(0);
      const [uncertainty, setUncertainty] = useState(TOLERANCE);
      const [calibCount, setCalibCount] = useState(0);
      const [defeatedIdx, setDefeatedIdx] = useState(null);
      const [startRealTime, setStartRealTime] = useState(null);
      const [startInstanceTime, setStartInstanceTime] = useState(null);
      const [tracking, setTracking] = useState(false);
      const [now, setNow] = useState(Date.now());
      const [statusMsg, setStatusMsg] = useState("");
      const [calibratedAt, setCalibratedAt] = useState(null);
      const [calibratedLoc, setCalibratedLoc] = useState(null);

      useEffect(() => {
        const hash = window.location.hash.slice(1);
        if (hash) {
          const state = decodeShareState(hash);
          if (state) {
            setStartRealTime(state.startRealTime);
            setStartInstanceTime(state.startInstanceTime);
            setOffset(state.offset);
            setUncertainty(state.uncertainty);
            setCalibCount(state.uncertainty <= 0.5 ? 2 : state.uncertainty <= 1 ? 1 : 0);
            setTracking(true);
            setStatusMsg("Loaded from shared link");
          }
        }
      }, []);

      useEffect(() => {
        if (tracking && startRealTime) {
          const code = encodeShareState(startRealTime, startInstanceTime, offset, uncertainty);
          history.replaceState(null, '', '#' + code);
        } else if (!tracking) {
          history.replaceState(null, '', window.location.pathname);
        }
      }, [tracking, startRealTime, startInstanceTime, offset, uncertainty]);

      useEffect(() => {
        const interval = setInterval(() => setNow(Date.now()), 1000);
        return () => clearInterval(interval);
      }, []);

      const currentInstanceTime = useCallback(() => {
        if (!tracking || !startRealTime) return 0;
        return startInstanceTime + (now - startRealTime) / 60000;
      }, [tracking, startRealTime, startInstanceTime, now]);

      const getSchedule = useCallback(() => {
        const instTime = currentInstanceTime();
        const startN = Math.max(0, Math.floor((instTime - offset - FATE_START) / FATE_INTERVAL) - 1);
        const fates = [];
        for (let n = startN; fates.length < 6; n++) {
          const t = fateTime(n);
          const adj = t + offset;
          const remaining = adj - instTime;
          const earlyRemaining = remaining - uncertainty;
          const lateRemaining = remaining + uncertainty;
          let status = "passed";
          if (earlyRemaining > 0.15) status = "upcoming";
          else if (lateRemaining > -0.5 && n !== defeatedIdx) status = "window";
          fates.push({ n, time: adj, loc: fateLoc(n), remaining, earlyRemaining, lateRemaining, status });
        }
        return fates;
      }, [currentInstanceTime, offset, uncertainty, defeatedIdx]);

      function handleStart(location) {
        const mins = parseInt(playerMin) || 0;
        const firstTime = location === "North" ? 5 : 35;
        let instanceTime = firstTime - mins;
        while (instanceTime < 0) instanceTime += 60;
        setStartInstanceTime(instanceTime);
        setStartRealTime(Date.now());
        setTracking(true);
        setOffset(0);
        setUncertainty(TOLERANCE);
        setCalibCount(0);
        setDefeatedIdx(null);
        setStatusMsg(`Tracking from ${location} estimate (\u00b15 min window)`);
      }

      function handleCalibrate(location) {
        const instTime = currentInstanceTime();
        // North FATEs at n=0,2,4,... (times 5,65,125,...) spaced 60min
        // South FATEs at n=1,3,5,... (times 35,95,155,...) spaced 60min
        const baseTime = location === "North" ? 5 : 35;
        const k = Math.max(0, Math.round((instTime - offset - baseTime) / 60));
        const bestN = location === "North" ? k * 2 : k * 2 + 1;

        const newOffset = instTime - fateTime(bestN);
        setDefeatedIdx(bestN);
        setOffset(newOffset);
        setCalibratedAt(Date.now());
        setCalibratedLoc(location);
        const newCount = calibCount + 1;
        setCalibCount(newCount);

        if (newCount === 1) {
          setUncertainty(1);
          setStatusMsg(`Calibrated to ${location} spawn! Shifted by ${newOffset > 0 ? "+" : ""}${newOffset.toFixed(1)} min. Now \u00b11 min.`);
        } else {
          setUncertainty(0.5);
          setStatusMsg(`Re-calibrated to ${location} spawn! Precision: \u00b130 sec.`);
        }
      }

      function handleReset() {
        setTracking(false);
        setPlayerMin("");
        setOffset(0); setUncertainty(TOLERANCE);
        setCalibCount(0); setDefeatedIdx(null); setCalibratedAt(null); setCalibratedLoc(null);
        setStartRealTime(null); setStartInstanceTime(null);
        setStatusMsg("");
      }

      function handleShare() {
        const code = encodeShareState(startRealTime, startInstanceTime, offset, uncertainty);
        const url = `${window.location.origin}/${code}`;
        navigator.clipboard.writeText(url).then(() => {
          setStatusMsg("Link copied to clipboard!");
        }).catch(() => {
          setStatusMsg(url);
        });
      }

      function handleJoin() {
        const code = joinCode.trim().toLowerCase();
        const state = decodeShareState(code);
        if (!state) { setStatusMsg("Invalid tracker code"); return; }
        setStartRealTime(state.startRealTime);
        setStartInstanceTime(state.startInstanceTime);
        setOffset(state.offset);
        setUncertainty(state.uncertainty);
        setCalibCount(state.uncertainty <= 0.5 ? 2 : state.uncertainty <= 1 ? 1 : 0);
        setTracking(true);
        setJoinCode("");
        setStatusMsg("Loaded from shared code");
      }

      const schedule = getSchedule();
      const upcoming = schedule.filter(f => f.status === "upcoming" || f.status === "window");
      const next = upcoming[0] || null;
      const afterNext = upcoming[1] || null;
      const showConfirmation = calibratedAt && (now - calibratedAt < 10000);

      useEffect(() => {
        if (!tracking || !next) return;
        if (next.remaining < -3) {
          setDefeatedIdx(next.n);
          setUncertainty(3);
          setCalibratedAt(null);
          setStatusMsg(`Auto-advanced past ${next.loc} \u2014 accuracy \u00b13 min`);
        }
      }, [tracking, now]);

      useEffect(() => {
        if (next && tracking) {
          const mins = Math.max(0, Math.ceil(next.remaining));
          document.title = `${mins}m - ${next.loc} Pots`;
        } else {
          document.title = "OC South - Pots FATE Tracker";
        }
      }, [next, tracking, now]);

      const confidenceColor = uncertainty <= 0.5 ? "#34d399" : uncertainty <= 1 ? "#6ee7b7" : uncertainty <= 3 ? "#fcd34d" : "#fdba74";
      const confidenceLabel = uncertainty <= 0.5 ? "High" : uncertainty <= 1 ? "Good" : uncertainty <= 3 ? "Fair" : "Estimate";

      const cardStyle = { background: "rgba(16,33,62,0.6)", borderRadius: 4, padding: 16, border: "1px solid rgba(191,163,76,0.25)", boxShadow: "inset 0 1px 0 rgba(191,163,76,0.08)" };
      const inputStyle = { width: 64, padding: "10px 8px", borderRadius: 4, border: "1px solid rgba(191,163,76,0.3)", background: "rgba(16,33,62,0.8)", color: "#e8e4dc", fontSize: 18, textAlign: "center", outline: "none" };
      const btnBase = { width: "100%", padding: "12px 16px", borderRadius: 4, border: "1px solid rgba(191,163,76,0.2)", color: "#fff", fontSize: 14, fontWeight: 600, cursor: "pointer" };
      const btnNorth = { flex: 1, padding: "16px 16px", borderRadius: 4, border: "1px solid rgba(191,163,76,0.35)", borderTop: "2px solid #5b7cd8", background: "linear-gradient(180deg, rgba(30,50,90,0.95), rgba(18,30,60,0.95))", color: "#93c5fd", fontSize: 15, fontWeight: 700, cursor: "pointer", boxShadow: "inset 0 1px 0 rgba(91,124,216,0.15), 0 2px 4px rgba(0,0,0,0.3)", fontFamily: "'Cinzel', serif", letterSpacing: 1, display: "flex", flexDirection: "column", alignItems: "center", gap: 4 };
      const btnSouth = { flex: 1, padding: "16px 16px", borderRadius: 4, border: "1px solid rgba(191,163,76,0.35)", borderTop: "2px solid #d4a040", background: "linear-gradient(180deg, rgba(65,38,18,0.95), rgba(45,25,12,0.95))", color: "#fdba74", fontSize: 15, fontWeight: 700, cursor: "pointer", boxShadow: "inset 0 1px 0 rgba(212,160,64,0.15), 0 2px 4px rgba(0,0,0,0.3)", fontFamily: "'Cinzel', serif", letterSpacing: 1, display: "flex", flexDirection: "column", alignItems: "center", gap: 4 };

      const locCardStyle = (loc) => ({
        borderRadius: 4, padding: 24, marginBottom: 16, textAlign: "center",
        background: loc === "North" ? "linear-gradient(135deg, rgba(59,130,246,0.12), rgba(59,130,246,0.03))" : "linear-gradient(135deg, rgba(249,115,22,0.12), rgba(249,115,22,0.03))",
        border: `1px solid ${loc === "North" ? "rgba(59,130,246,0.25)" : "rgba(249,115,22,0.25)"}`,
        boxShadow: "inset 0 1px 0 rgba(191,163,76,0.06)",
      });
      const locColor = (loc) => loc === "North" ? "#93c5fd" : "#fdba74";

      return (
        <div>
          <h1 style={{ fontSize: 24, fontWeight: 700, textAlign: "center", marginBottom: 2, fontFamily: "'Cinzel', serif", background: "linear-gradient(180deg, #d4c078, #bfa34c)", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent" }}>
            Occult Crescent South
          </h1>
          <p style={{ textAlign: "center", fontSize: 13, color: "#a9a6a0", marginBottom: 12, fontFamily: "'Cinzel', serif", letterSpacing: 1 }}>
            Pots FATE Tracker
          </p>
          <div style={{ height: 1, background: "linear-gradient(to right, transparent, rgba(191,163,76,0.5), transparent)", marginBottom: 20 }} />

          {!tracking ? (
            <div style={cardStyle}>
              <label style={{ fontSize: 14, color: "#a9a6a0", marginBottom: 12, display: "block" }}>
                Estimated minutes until next Pots FATE:
              </label>
              <div style={{ display: "flex", gap: 8, alignItems: "center", marginBottom: 8 }}>
                <div style={{ display: "flex", flexDirection: "column", alignItems: "center" }}>
                  <input type="number" min="0" max="60" placeholder="0" value={playerMin} onChange={(e) => setPlayerMin(e.target.value)} style={{ ...inputStyle, width: 100 }} />
                  <span style={{ fontSize: 11, color: "#6e6b65", marginTop: 4 }}>minutes</span>
                </div>
              </div>
              <p style={{ fontSize: 11, color: "#6e6b65", marginBottom: 16, lineHeight: 1.5 }}>
                Enter your best guess, then tap which location it will be. Predictions start {"\u00b1"}5 min {"\u2014"} calibrate when a FATE spawns to tighten it.
              </p>
              <div style={{ display: "flex", gap: 10 }}>
                <button onClick={() => handleStart("North")} style={btnNorth}>
                  <span style={{ fontSize: 18 }}>{"\u2726"}</span>
                  <span>North Pots</span>
                </button>
                <button onClick={() => handleStart("South")} style={btnSouth}>
                  <span style={{ fontSize: 18 }}>{"\u2726"}</span>
                  <span>South Pots</span>
                </button>
              </div>
              <div style={{ marginTop: 16, paddingTop: 16, borderTop: "1px solid rgba(191,163,76,0.15)" }}>
                <div style={{ fontSize: 12, color: "#6e6b65", marginBottom: 8 }}>Or join an existing tracker:</div>
                <div style={{ display: "flex", gap: 8 }}>
                  <input type="text" placeholder="flame-frost-stone-wind" value={joinCode} onChange={(e) => setJoinCode(e.target.value)} onKeyDown={(e) => e.key === "Enter" && handleJoin()} style={{ ...inputStyle, flex: 1, width: "auto", fontSize: 14, textAlign: "left", padding: "8px 10px" }} />
                  <button onClick={handleJoin} style={{ ...btnBase, width: "auto", padding: "8px 16px", background: "rgba(16,33,62,0.6)", color: "#d4c078", border: "1px solid rgba(191,163,76,0.3)", fontSize: 13 }}>Join</button>
                </div>
                {statusMsg && !tracking && <p style={{ fontSize: 11, color: "#fdba74", marginTop: 8 }}>{statusMsg}</p>}
              </div>
            </div>
          ) : (
            <>
              {showConfirmation && calibratedLoc ? (
                <div style={locCardStyle(calibratedLoc)}>
                  <div style={{ fontSize: 12, color: "#a9a6a0", marginBottom: 4 }}>{calibratedLoc} Pots FATE</div>
                  <div style={{ fontSize: 36, fontWeight: 700, marginBottom: 10, color: locColor(calibratedLoc), fontFamily: "'Cinzel', serif" }}>
                    {calibratedLoc}
                  </div>
                  <div>
                    <div style={{ fontSize: 24, fontWeight: 700, color: "#34d399" }}>{"\u2714"} Spawn confirmed</div>
                    <div style={{ fontSize: 12, color: "#a9a6a0", marginTop: 4 }}>Schedule synced {"\u2014"} tracking next spawn</div>
                  </div>
                </div>
              ) : next && (
                <div style={locCardStyle(next.loc)}>
                  <div style={{ fontSize: 12, color: "#a9a6a0", marginBottom: 4 }}>Next Pots FATE</div>
                  <div style={{ fontSize: 36, fontWeight: 700, marginBottom: 4, color: locColor(next.loc), fontFamily: "'Cinzel', serif" }}>
                    {next.loc}
                  </div>
                  <div style={{ fontSize: 11, color: confidenceColor, marginBottom: 10 }}>
                    {confidenceLabel} accuracy <span style={{ fontWeight: 400, opacity: 0.8 }}>({"\u00b1"}{uncertainty <= 1 ? `${Math.round(uncertainty * 60)}s` : `${uncertainty}m`})</span>
                  </div>
                  {next.status === "window" ? (
                    <div>
                      <div style={{ fontSize: 26, fontWeight: 700, color: "#fbbf24" }}>{calibCount > 0 ? "\u26a1 Spawning!" : "\u26a1 Spawn window open"}</div>
                      <div style={{ fontSize: 12, color: "#a9a6a0", marginTop: 4 }}>{calibCount > 0 ? `Head to ${next.loc}!` : `Estimated window \u2014 up to ${fmtShort(Math.max(0, next.lateRemaining))} from now`}</div>
                    </div>
                  ) : (
                    <div>
                      <div style={{ fontSize: 13, color: "#a9a6a0", marginBottom: 4 }}>Spawns in</div>
                      <div style={{ display: "flex", justifyContent: "center", alignItems: "baseline", gap: 6 }}>
                        <span style={{ fontSize: 12, color: confidenceColor }}>{fmtShort(Math.max(0, next.earlyRemaining))}</span>
                        <span style={{ fontSize: 32, fontWeight: 700, color: "#e8e4dc" }}>{fmtShort(Math.max(0, next.remaining))}</span>
                        <span style={{ fontSize: 12, color: confidenceColor }}>{fmtShort(Math.max(0, next.lateRemaining))}</span>
                      </div>
                      <div style={{ fontSize: 11, color: "#a9a6a0", marginTop: 4 }}>early {"\u2014"} best guess {"\u2014"} late</div>
                      <div style={{ fontSize: 14, color: "#d4c078", marginTop: 10 }}>~{fmtTime(next.remaining)}</div>
                      <div style={{ marginTop: 14, height: 5, borderRadius: 2, background: "rgba(191,163,76,0.1)", position: "relative", overflow: "hidden" }}>
                        {(() => {
                          const total = 30;
                          const center = Math.max(0, Math.min(next.remaining, total));
                          const early = Math.max(0, center - uncertainty);
                          const late = Math.min(total, center + uncertainty);
                          return <div style={{ position: "absolute", left: `${(early / total) * 100}%`, width: `${((late - early) / total) * 100}%`, height: "100%", borderRadius: 2, background: `linear-gradient(90deg, ${confidenceColor}44, ${confidenceColor}aa, ${confidenceColor}44)` }} />;
                        })()}
                      </div>
                    </div>
                  )}
                </div>
              )}

              {afterNext && (
                <div style={{
                  ...cardStyle, marginBottom: 16, display: "flex", justifyContent: "space-between", alignItems: "center",
                }}>
                  <div>
                    <div style={{ fontSize: 11, color: "#a9a6a0" }}>After That</div>
                    <div style={{ fontSize: 20, fontWeight: 700, color: locColor(afterNext.loc), fontFamily: "'Cinzel', serif" }}>{afterNext.loc}</div>
                  </div>
                  <div style={{ textAlign: "right" }}>
                    <div style={{ fontSize: 18, fontWeight: 600, color: "#e8e4dc" }}>{fmtShort(Math.max(0, afterNext.remaining))}</div>
                    <div style={{ fontSize: 12, color: "#a9a6a0" }}>~{fmtTime(afterNext.remaining)}</div>
                  </div>
                </div>
              )}

              <div style={{ ...cardStyle, marginBottom: 16 }}>
                <div style={{ fontSize: 13, fontWeight: 600, color: "#d4c078", marginBottom: 6 }}>
                  {calibCount > 0 ? "Re-Calibrate" : "Calibrate"} {"\u2014"} FATE Just Spawned?
                </div>
                <p style={{ fontSize: 12, color: "#6e6b65", marginBottom: 14, lineHeight: 1.5 }}>
                  When a FATE spawns, tap the matching location button to sync the schedule.
                </p>
                <div style={{ display: "flex", gap: 10 }}>
                  <button onClick={() => handleCalibrate("North")} style={btnNorth}>
                    <span style={{ fontSize: 18 }}>{"\u2726"}</span>
                    <span>North Spawned</span>
                  </button>
                  <button onClick={() => handleCalibrate("South")} style={btnSouth}>
                    <span style={{ fontSize: 18 }}>{"\u2726"}</span>
                    <span>South Spawned</span>
                  </button>
                </div>
                {statusMsg && <p style={{ fontSize: 11, color: confidenceColor, marginTop: 10 }}>{statusMsg}</p>}
              </div>

              <div style={{ display: "flex", gap: 10 }}>
                <button onClick={handleShare} style={{ ...btnBase, flex: 1, background: "linear-gradient(135deg, #8c7635, #bfa34c)", border: "1px solid rgba(191,163,76,0.4)" }}>Share Link</button>
                <button onClick={handleReset} style={{ ...btnBase, flex: 1, background: "rgba(16,33,62,0.6)", color: "#a9a6a0", border: "1px solid rgba(191,163,76,0.15)" }}>Reset</button>
              </div>
            </>
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<FateTracker />);
  </script>
</body>
</html>
